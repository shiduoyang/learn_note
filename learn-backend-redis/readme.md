1. redis的数据结构有哪些
    * string
    * hash
    * set
    * zset
    * list
2. redis为什么这么快
    1. 基于内存
    2. I/O多路复用技术，支持并发的连接
    3. 且用一个线程处理所有的命令。
    **省去了山下文切换的时间，不用考虑锁的问题；且可处理并发的连接** 
            基于I/O多路复用机制的线程模型，可以处理并发的连接
            * 文件处理器包含四个部分（接收请求，放队列，每次拿一个，处理）
                1. 多个socket
                2. IO多路复用程序（用来接收各种请求）
                3. 文件事件分派器
                4. 事件处理器（命令请求处理器，命令回复处理器，命令应答处理器）
            * “多路”指的是多个网络连接；“复用”指的是复用同一个线程
            * 多路I/O复用模型是利用select，poll,epoll可以同时检查多个流的I/O的能力
    3. 在数据存储时会有选择的使用不同的底层数据结构
        1. list在容量较小时，存成zipList,否则linkedList
        2. hash在容量较小时，也会存成ziplist，否则存成hashtable
        3. zset在容量较小时，也会存成ziplist, 否则存成skipList, 同时保存在字典和跳跃表中
3. 为什么redis是单线程
    * 用一个线程来处理所有网络请求
4. redis是单线程，如何发挥多核CPU的优势
    * 在单机开多个redis实例
4. select poll epoll 了解吗
    他们都是IO多路复用的机制
    * select  事件驱动模型只用单线程执行，适合创建一个简单的事件驱动的服务器程序，它有最大连接数的限制
    * pool 原理与select相似，他没有最大连接数的限制
    * epoll 是一种I/O时间通知机制，是linux内核实现IO多路复用的一个实现。I/O多路复用是：在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，单后对其操作
    效率更高：select pool 都是用轮训的方式，epoll是时间通知的形式
5. skipList的结构了解吗？
    * skiplist的结构，是在有序的链表之上建立索引
    * 其查找的时间复杂度，是log2n
6. redis缓存穿透，击穿，雪崩是什么，该如何解决
    * 缓存穿透：找一个缓存中没有的数据，只能去DB查
        * 解决：缓存空对象
        * 解决2：布隆过滤器（用某比特位表示key是否存在，需要对某key进行hash计算得到一个位的位置）
    * 缓存击穿：缓存键过期时，大量的请求穿过缓存，进入DB
        * key永不过期
        * 分布式锁，同时只有一个请求重新加载热点数据到缓存中，其他的等待（同时只能有一个请求获取到该key的锁进行查询）
    * 缓存雪崩：大量的键过期
        * 将每个key的过期时间打散
7. redis的应用场景
    1. 做缓存
    2. 做排行榜
    3. 当锁
8. redis的持久化
    1. rdb 
    2. aof
9. redis的过期策略和淘汰策略
    1. 过期策略
        * 定时删除：设定过期时间时创建个定时器
        * 惰性删除：每次取key时检查该key是否过期
        * 定期删除：每隔一段时间删
10. 管道pipline
    1. 管道 从请求上或者响应上批量处理